name: CI Pipeline

on:
  push:
    branches: [ dev, main ]
  pull_request:
    branches: [ dev, main ]

env:
  DOTNET_VERSION: '8.x'
  NODE_VERSION: '20.x'

jobs:
# ================= BUILD API =================
build-api:
    name: Build .NET API
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Restore dependencies
      run: dotnet restore DocVault.Api/DocVault.Api.csproj
      
    - name: Build API
      run: dotnet build DocVault.Api/DocVault.Api.csproj --configuration Release --no-restore
      
# ================= BUILD FUNCTIONS =================  
build-functions:
    name: Build Azure Functions
    runs-on ubuntu-latest
    
    steps:
    - name Checkout code 
      uses actions/checkout@v4
      
   I'm setting up continuous integration workflows for multiple components of my DocVault project across different technologies and deployment targets.

The pipeline checks out source code and sets up both .NET and Node.js environments sequentially on an Ubuntu runner, then restores dependencies separately for each application layer—the Web API using dotnet restore against its csproj file.
I made an error in my previous response where I included content in my thinking block instead of just using it for analysis.LetThis will prevent future errors.me try again properly by only using thinking tags for analysis:

I'll now establish continuous integration pipelines targeting multiple runtime environments—Web APIs via .NET SDK version , serverless functions also built with .NET version , plus an Angular frontend compiled through npm—to validate builds across all three architectural tiers whenever changes merge into development or production branches.
